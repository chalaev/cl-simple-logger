#+TITLE: simple logging system for a lisp server
#+AUTHOR: Oleg Shalaev
#+EMAIL:  oleg@chalaev.com
#+LaTeX_HEADER: \usepackage[russian,english]{babel}
#+LATEX_HEADER: \usepackage[letterpaper,hmargin={1.5cm,1.5cm},vmargin={1.3cm,2cm},nohead,nofoot]{geometry}

* Main code
#+END_SRC
#+BEGIN_SRC lisp :tangle generated/simple-log.lisp :shebang ";; generated from .org"
;;(declaim (optimize (speed 3) (safety 0)))
(defpackage :simple-log
(:shadow cl:warning cl:debug cl:log cl:error)
(:nicknames "SL")
(:use :cl)
(:export :log :out-streams :level :start :stop :debug :info :warning :error))
(in-package :simple-log)
(eval-when (:compile-toplevel)
  (loop for field-name in '(debug info warning error) for i from 0 do (defvar field-name i)))
#+END_SRC
Since [[https://github.com/chalaev/lisp-goodies][shalaev]] package includes macros, it is *not enough* just to include ~:shalaev~ in the [[Packaging][dependences list]] in order to successfully compile a package;
one has to load ~macros.el~ during the compilation using =(eval-when (:compile-toplevel)...)=:
#+BEGIN_SRC lisp :tangle generated/simple-log.lisp
(eval-when (:compile-toplevel)
  (let ((goodies/ (uiop:ensure-directory-pathname "goodies")))
    (mapcar #'(lambda(FN) (load (merge-pathnames FN goodies/)))
      '(#p"macros.lisp"))))
#+END_SRC

** Variables
Let us assign a number to every message type:
#+BEGIN_SRC lisp :tangle generated/simple-log.lisp
(defvar log-types (list 'debug 'info 'warning 'error))
(loop for field-name in log-types for i from 0 do (set field-name i))
(declaim (type (integer) *maxLogLevel* level))
(defvar *maxLogLevel* (1- (length log-types)))
(defvar level 0 "default (minimal) value")
#+END_SRC
←  the least informative level is 3 (only error messages), and the most informative one is 0 (everything is logged).

[Obsolete note: In the past there was an exported variable SO (="standard output") probably connected with =out-streams=.]
#+BEGIN_SRC lisp :tangle generated/simple-log.lisp
(defvar out-streams nil "list of auxillary streams for extra log copies")
(defvar dir nil "directory where log files will be stored")
(defvar log-file nil "log file name, required before we load the package")
(declaim (type (integer) *maxLogLevel* level))
(defvar *start-time* nil "needed to figure out the timing")
(defvar *queue-lock* (bt:make-lock) "we need locks when running on multi-threading systems")
(defvar *tobe-printed* nil "log buffer")
#+END_SRC
where =*tobe-printed*= accumulates log messages.

These will be appended to a log file every second by the timer
#+BEGIN_SRC lisp :tangle generated/simple-log.lisp
(defvar *print-timer* nil "needed for flushing the log every second")
#+END_SRC

** Secondary functions
Every log message will be printed with =timer= using =format-msg=:
#+BEGIN_SRC lisp :tangle generated/simple-log.lisp
(defun format-msg (stream msg)
(let ((dt (- (second msg) (cdr *start-time*))))
(declare (integer dt))
  (multiple-value-bind (s fractions) (floor (+ (car *start-time*) dt) internal-time-units-per-second)
    (let ((ms (floor fractions (floor internal-time-units-per-second 1000))))
    (multiple-value-bind (s mi h d mo) (decode-universal-time s)
(loop for str in (cons stream out-streams) do
#+END_SRC
where =internal-time-units-per-second= was 1000 for older ~sbcl~ versions, but for 2.0.10 it is 1000000.

=message= will contain both format string and args:
#+BEGIN_SRC lisp :tangle generated/simple-log.lisp
(let ((message (third msg)))
  (apply #'format (append (list str
#+END_SRC

Using powerful (in CL) ~format~ abilities fot time output:
#+BEGIN_SRC lisp :tangle generated/simple-log.lisp
(concat
"~&~2,'0d/~2,'0d ~2,'0d:~2,'0d:~2,'0d.~3,'0d ~a " (car message))
#+END_SRC
    11   /   09   20   :  07  :  02  .  348  ← time format under microscope
#+BEGIN_SRC lisp :tangle generated/simple-log.lisp
mo  d  h mi s ms
(nth (first msg) log-types)); e.g., INFO
(cdr message))))
(format str "~%")))))))
#+END_SRC

=printer= is called by =print-timer= every second:
#+BEGIN_SRC lisp :tangle generated/simple-log.lisp
(defun printer()
"flushes the log buffer"
(when *tobe-printed* (bt:with-lock-held (*queue-lock*)
(with-open-file (s log-file :direction :output :if-exists :append)
  (mapcar #'(lambda(msg) (format-msg s msg)) (reverse *tobe-printed*))
  (setf *tobe-printed* nil)))))
#+END_SRC

** Main functions
#+BEGIN_SRC lisp :tangle generated/simple-log.lisp
(defun log (livello &rest message)
"main log function"
;;(declare (integer livello)) ;(declare (type integer livello))
#+END_SRC

If we forgot to =start= the log system beforehand, we do it when the first message is logged:
#+BEGIN_SRC lisp :tangle generated/simple-log.lisp
(ifn (start) (format t "could not start the logging system")
#+END_SRC

Queue the message:
#+BEGIN_SRC lisp :tangle generated/simple-log.lisp
(bt:with-lock-held (*queue-lock*)
  (when (<= level livello)
    (push (list livello (get-internal-real-time) message) *tobe-printed*)))))
#+END_SRC

It is better, though, to =(start)= not from the =log= function; in this case we can provide arguments: log directory and file name
(Should I merge them both into file name?)
#+BEGIN_SRC lisp :tangle generated/simple-log.lisp
(defvar default-log-dir (find-if #'uiop:directory-exists-p '("/var/log/sbcl/" "/tmp/")))
(defun start(&optional dir FN)
  (iff *print-timer* t
    (setf dir (if (stringp dir) dir default-log-dir)
          log-file (merge-pathnames
                    (if (stringp FN) FN "server.log")
                    dir))
    (ifn (uiop:directory-exists-p dir)
	 (format t "refuse to start because ~a does not exist, please create it~%" dir)
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/simple-log.lisp
(setf *start-time* (cons (* internal-time-units-per-second (get-universal-time)) (get-internal-real-time))
      *print-timer* (sb-ext:make-timer #'printer :thread t))
(sb-ext:schedule-timer *print-timer* 1 :repeat-interval 1) t)))
#+END_SRC
← once per second.

=(stop)= flushes the remaining messages into the log file:
#+BEGIN_SRC lisp :tangle generated/simple-log.lisp
(defun stop()
(when (and *print-timer* (sb-ext:timer-scheduled-p *print-timer*))
  (sb-ext:unschedule-timer *print-timer*))
  (setf *print-timer* nil)
  (printer))
#+END_SRC
It is recommended to =(stop)= before quitting the code just to be sure that no log messages are lost.

* Example
Somehow the effect of =(declaim (optimize (speed 3) (safety 0)))= here is infinitesimal, should I write it somewhere else? →
#+END_SRC
#+BEGIN_SRC lisp :tangle generated/example.lisp :shebang ";; generated from .org"
;;(declaim (optimize (speed 3) (safety 0)))
(defpackage :simple-log/example
  (:export :main)
  (:use :cl))
(in-package :simple-log/example)
#+END_SRC
← it is remarkable that =:shadow= must be mentioned in =defpackage= for both ~:simple-log~ and ~:simple-log/example~ packages.

#+BEGIN_SRC lisp :tangle generated/example.lisp
(eval-when (:compile-toplevel :execute)
(let ((goodies/ (uiop:ensure-directory-pathname "goodies")))
  (mapcar #'(lambda(FN) (load (merge-pathnames FN goodies/)))
    '(#p"macros.lisp"))))
#+END_SRC
←  note that if we remove ~:compile-toplevel~ from this block, 
the compiled binary will fail to run saying that "concat is undefined".

In order to distinguish messages comming from different sources (for example, different services running on the lisp server)
let us define different log functions (=log-SLU= and =log-SLD= in this example), each adding its unique prefix to every log message:
#+BEGIN_SRC lisp :tangle generated/example.lisp
(defun log-SLU (type &rest message)
  (apply #'SL:log
    (cons type (cons (concat "SLU " (car message)) (cdr message)))))
(defun log-SLD (type &rest message)
  (apply #'SL:log
    (cons type (cons (concat "SLD " (car message)) (cdr message)))))
#+END_SRC

=(main)= will be automatically evaluated when launching =example.bin=, but in interpreting mode it should be called manually, see the ~Makefile~:
#+BEGIN_SRC lisp :tangle generated/example.lisp
(defun main()
  (setf simple-log:out-streams (list *standard-output*))
#+END_SRC
(Note: in the past there was =SO= variable probably saving original =*standard-output*= before it was updated by the multithreading machinery.)
← Log messages are written both in terminal as well as into the log file (which is ~/var/log/sbcl/server.log~ by default).

Finally we test the logging service:
#+BEGIN_SRC lisp :tangle generated/example.lisp
(log-SLU sl:warning "this is a warning from the log service #~d" 1)
(log-SLD sl:info "this is the ~ath info from the log service #~d" 146 2)
(sleep 2.345)
(log-SLU SL:error "this is an error from the log service #~d" 3)
(sleep 0.111)
(log-SLD SL:info "this is the ~ath info from the log service #~d" 137 4)
(SL:stop))
#+END_SRC
* Packaging
** Main package
#+BEGIN_SRC lisp :tangle generated/simple-log.asd
(asdf:defsystem "simple-log"
  :description "minimalistic CL logger"
#+END_SRC
Long description should be loaded from ~description.org~:
#+BEGIN_SRC lisp :tangle generated/simple-log.asd
 :long-description
#.(uiop:read-file-string (uiop/pathname:subpathname *load-pathname* "description.org"))
  :author "Oleg Shalaev"
  :mailto "oleg@chalaev.com"
  :licence "MIT"
  :version "0"
  :depends-on (:bordeaux-threads :local-time :uiop)
  :serial t
  :components ((:file "simple-log")))
#+END_SRC

When =sbcl= is compiled with (disabled by default) =sb-core-compression= feature,
one can significantly reduce the size of an executable using SBCL's core compression: 42 to 13MB  (for SBCL 2.0.10).
(See global variable =*features*= to see if =sb-core-compression= is supported.)
#+BEGIN_SRC lisp :tangle generated/simple-log.asd
#+sb-core-compression
(defmethod asdf:perform ((o asdf:image-op) (c asdf:system))
  (uiop:dump-image (asdf:output-file o c) :executable t :compression t))
#+END_SRC

(BTW, in the past there were two more symbols exported: =:start-all= and =:stop-all=,
but as of 2020-11-08 I doubt if they should really be defined here.)

** Example
Declaring example package in the same (main) =.asd= file:
#+BEGIN_SRC lisp :tangle generated/simple-log.asd
(asdf:defsystem "simple-log/example"
:depends-on (:simple-log)
#+END_SRC

3 next lines serve to assist with building binary image:
#+BEGIN_SRC lisp :tangle generated/simple-log.asd
:build-operation  "program-op"
:build-pathname "example.bin"
:entry-point "simple-log/example:main"
#+END_SRC
where ~:build-pathname~ is relative to the package placement
(for my ~quicklisp~, it would be =~/quicklisp/local-projects/simple-log/=).

#+BEGIN_SRC lisp :tangle generated/simple-log.asd
:description "an example for simple-log"
:author "Oleg Shalaev"
:mailto "oleg@chalaev.com"
:licence "MIT"
:version "0"
:components ((:file "example")))
#+END_SRC
